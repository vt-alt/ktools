#!/bin/bash
set -eu +o posix
shopt -s extglob

grepcmd='grep'
selector='fzf --highlight-line'
unset mode offset difftool pattern
multi=
for opt do
        shift
        case "$opt" in
		-+([0-9])) offset=${opt#-} ;;
		--grep|-ug|--ug|--ugrep|-rg|--rg) grepcmd=${opt##+(-)} ;&
		-g) mode=GREP; break ;;
		--sk | --skim) selector='sk' ;;
		--multi) multi=--multi ;;
		--logdiff | --logdiff2) difftool=${opt#--} ;;
		--diff-grep=*) pattern+=("${opt#*=}") ;;
		-f | --filename) print_filename=y ;;
		--) break ;;
		-*) echo >&2 "Error: unknown option: $opt"; exit 1 ;;
                *) set -- "$@" "$opt";;
        esac
done
toplevel=$(git rev-parse --show-toplevel)
logdir="$toplevel/.git/bb"
[ -d "$logdir" ] && cd "$logdir"

mapfile -t files < <(ls -1tr "log"*)

if [ -v mode ]; then
	for o; do [[ $o = -l ]] && mode=LIST; done
	if [[ $mode == LIST ]]; then
		mapfile -t files < <(grep "$@" "${files[@]}")
	else
		$grepcmd --color=auto "$@" "${files[@]}"
		exit
	fi
fi

tui_selector() {
	# shellcheck disable=SC2012,SC2207,SC2016
	date=$(date +%F)
	files=($(ls -1tr "${files[@]}" |
		GREP_COLORS="mt=1;32" grep --color=always -Ee "$date|" |
		$selector \
		"$@" \
		--ansi \
		--bind='q:abort,/:unbind(q)+unbind(/)' \
		--no-mouse \
		--no-sort \
		--tac \
		$multi \
		--preview-window=80% \
		--preview='head -$((LINES/2-1)) {}; echo ...; tail -$((LINES/2)) {}'))
}

if [ -v offset ]; then
	# Start from 0 like, Nth previous log file.
	# (Similar to sar -N or journalctl -b N)
	offset=$((offset+1))
	files=($(ls -1tr "${files[@]}" | tac | sed -n "${offset}p"))
elif (( $# )); then
	files=("$@")
fi
if [ -v difftool ]; then
	(( ${#files[@]} == 2 )) || tui_selector --multi
	if (( ${#files[@]} == 2 )); then
		if [ -v pattern ]; then
			"$difftool" <(grep "${pattern[@]}" "${files[0]}") <(grep "${pattern[@]}" "${files[1]}")
		else
			"$difftool" "${files[@]}"
		fi | delta --max-line-length=99999
		exit
	else
		echo "Need to select two logs (using TAB)" >&2
		exit 1
	fi
fi
(( ${#files[@]} <= 1 )) || tui_selector
(( ${#files[@]} )) || exit
if [ -v print_filename ]; then
	realpath "${files[@]}"
elif [ ${#files[@]} -eq 1 ]; then
	# To show the filename in prompt.
	less "${files[@]}"
else
	# This may be used to grep selected logs.
	head -n-0 "${files[@]}" | less
fi
