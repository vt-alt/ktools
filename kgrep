#!/bin/bash
set -eu +f

export LC_ALL=C
export GREP_COLORS="mt=1;32"
export GIT_GREP_COLOR=(-c "color.grep.match=green bold")

[ -t 1 ] && color=--color=always || color=
_color=$color

unset update log all alt
_grep=grep
_setx=:
grep_opt=
git_fp=
for opt do
        shift
        case "$opt" in
		--update) update=y ;;
		--log) log=y ;;
		--blame) _grep=blame-grep; _color= ;;
		-[[:digit:]]) grep_opt+=" $opt" ;;
		-v) _setx="set -x" ;;
		--first-parent) git_fp=$opt ;;
		-x | --extra) all=y ;;
		-a | --alt) alt=y ;;
		-*) echo >&2 "unknown option: $opt"; exit 1 ;;
                *) set -- "$@" "$opt";;
        esac
done

if [ -v alt ]; then
	($_setx; list-kernels s def --show-no-match --grep "$@")
fi

cd ~/linux
while read -r root br dir; do
	[[ "$root" =~ ^[[:space:]]*\# ]] && continue
	[[ "$root" =~ ^\? ]] && [ ! -v all ] && continue
	root=${root#\?}
	cd ~/linux/"$root"
	if [ "${br:-@}" = '@' ]; then
		branch=$(git branch --show-current)
		br=
	else
		branch=$br
	fi
	if [ -f ".git/refs/remotes/$branch" ]; then
		remote=${branch%%/*}
	else
		remote=
	fi
	if [ -v update ]; then
		figlet -t "$root${remote:+ : $remote}"
		if [ -d .git ]; then
			if [ "$br" = '' ]; then
				(set -x; git pull --rebase)
			elif [ -n "$remote" ]; then
				(set -x; git fetch "$remote")
			else
				echo -e >&2 "\e[1;31m- $PWD unknown how to update branch $branch\e[m"
				continue
			fi
			git l -1 $br
		else
			echo -e >&2 "\e[1;35m- $PWD is not a git repository.\e[m"
		fi
		continue
	fi
	if [ -v log ]; then
		[ -d .git ] || continue
		echo ":: $root [$branch]"
		git l ${grep_opt:--1} $git_fp $br
		echo
		continue
	fi
	if [ -d .git ]; then
		($_setx; git "${GIT_GREP_COLOR[@]}" "$_grep" $grep_opt $_color "$@" $br -- $dir)
	else
		grep $grep_opt $color "$@" -r $dir
	fi | sed "s:^:$root | :" | sed -E \
		-e '/is not set/s/\x1b\[1;32m/\x1b\[1;33m/g' \
		-e 's/(x86([_-]64)?|amd64)/\x1b[1m\1\x1b[22m/g'

done < ".kgrep.conf"
