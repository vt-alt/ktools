#!/bin/bash
# Easy-peasy single command robot-bobot package update script
# Copyright (c) 2022 Vitaly Chikunov <vt@altlinux.org>
#
# shellcheck disable=SC2128,SC2207

# shellcheck source=/usr/bin/gear-utils-sh-functions
. gear-utils-sh-functions

set -euo pipefail
shopt -s extglob

V() {
        printf >&2 '\e[1;32m+'
        printf >&2 ' %q' "$@"
        printf >&2 '\e[m\n'
        "$@"
}

fatal() {
	printf >&2 "\e[1;31mError: %s\e[m\n" "$*"
	exit 1
}

warn() {
	printf >&2 "\e[1;34mWarning: %s\e[m\n" "$*"
}

info() {
	printf >&2 "\e[1;36minfo: %s\e[m\n" "$*"
}

force='' build='' push='' commit='' theirs=''
gears_update=y
keyserver="--auto-key-locate wkd"
unset nosignature
while [ $# -gt 0 ]; do
	opt=$1
	case "$opt" in
		-f | --force) force=-f ;;
		--build) build=y ;;
		--push)  build=y; push=y ;;
		--commit | --test-only) build=y; push=y; commit=$opt ;;
		--theirs ) theirs='-X theirs' ;;
		--no-gears ) unset gears_update ;;
		--all) build=y push=y commit=--commit ;;
		--keyserver=ubuntu) keyserver="--keyserver hkps://keyserver.ubuntu.com" ;;
		--keyserver) shift; keyserver="--keyserver $1" ;;
		--nosignature) nosignature=y ;;
		*) fatal "Unknown option: $opt" ;;
	esac
	shift
done

export disable_specsubst=1
chdir_to_toplevel
guess_specfile
# Sets '$specfile'.
export specfile

gear_describe() {
	# shellcheck disable=SC2046
	set -- $(gear --describe --disable-specsubst)
	export NAME=$1 VERSION=$2 RELEASE=$3
}
gear_describe

# Update repos
V git fetch origin
if [ -v gears_update ]; then
	V git gears-add
	git l gears/${branch-sisyphus}..
fi

# Find latest (merged) upstream tag in this branch
unset oldtag
while read -r tag; do
	case "$tag" in
		@ | gb-*-task* | *-alt*) continue ;;
	esac
	oldtag=$tag
	echo "Latest merged tag is $oldtag"
	break
done < <(git tag --sort=-creatordate --merged @)

# Find new tags
tags=()
while read -r tag; do
	[[ $tag =~ -alt|^gb-|rc|beta|alpha ]] && continue
	# --is-ancestor: Check if the first <commit> is an ancestor of the second <commit>, and exit with status 0 if true.
	git merge-base --is-ancestor "$tag" HEAD && break
	# Consider only tags in this branch
	# [ -v oldtag ] && { git merge-base --is-ancestor "$oldtag" "$tag" || continue; }
	tags+=( "$tag" )
done < <(git tag --sort=-creatordate -l)

case ${#tags[@]} in
	0) warn "No new tags."; tag= ;;
	1) tag=$tags ;;
	*) tag=$(gum choose -- "${tags[@]}") ;;
esac
echo "Selected tag: $tag"

# Prepare GPG
export GNUPGHOME=.gear/.gnupg
rm -rf "$GNUPGHOME"
(umask 077; mkdir -p "$GNUPGHOME")
# Basically we want keyserver set to
#   keyserver hkps://keys.openpgp.org
cp -a ~/.gnupg/gpg.conf $GNUPGHOME/
# Hide:
#   gpg: WARNING: This key is not certified with a trusted signature!
#   gpg:          There is no indication that the signature belongs to the owner.
echo "trust-model always" >> $GNUPGHOME/gpg.conf
GPGKEYS=.gear/keys.gpg
if [ -v nosignature ]; then
	warn "Importing gpg keys skipped."
	# Call 'gpg' to initialize keyring, or else it will add to commit message:
	# "gpg: keybox '/home/vt/src/libkdumpfile/.gear/.gnupg/pubring.kbx' created"
	gpg2 --list-keys >/dev/null 2>&1
elif [ -e "$GPGKEYS" ]; then
	declare -p GNUPGHOME
	V gpg2 --quiet --import "$GPGKEYS"
fi

acquire_gpg_key() {
	local tag=$1
	if [ -e .gear/keys.gpg ]; then
		echo >&2 "GPG key is known."
		return
	fi
	local object_type=$(git cat-file -t "$tag")
	git cat-file -p "$tag" | grep -e committer -e tagger
	echo "git verify-$object_type $tag" > .gear/GIT_VERIFY_OUTPUT
	git verify-$object_type "$tag" >> .gear/GIT_VERIFY_OUTPUT 2>&1 || :
	keyid=$(grep -Po "^gpg:\s+using \S+ key \K.*" .gear/GIT_VERIFY_OUTPUT)
	[ -n "$keyid" ] || fatal "No keyid to find."
	# --receive-keys cannot receive unapproved keys: https://keys.openpgp.org/about/faq#older-gnupg
	gpg_command="gpg2 $keyserver --receive-keys $keyid"
	V $gpg_command |& tee -a .gear/GIT_VERIFY_OUTPUT
	local who=$(grep -Po '^gpg: key \S+: public key "\K[^"]+(?=" imported)' .gear/GIT_VERIFY_OUTPUT)
	[ -n "$who" ] || fatal "Key is not imported."
	V gpg2 --list-keys
	V gpg2 --export -a > .gear/keys.gpg
	V git add -f .gear/keys.gpg
	V git commit -m "ALT: Import GPG key for $who" -m "$gpg_command"
}

# Have tag to merge.
if [ -n "$tag" ]; then
	msg=
	cleanup=
	if [ -v nosignature ]; then
		warn "Signature check skipped."
		tagstate=nosignature
	elif git cat-file -p "$tag" | grep -q 'BEGIN PGP SIGNATURE'; then
		acquire_gpg_key "$tag"
		# Hide:
		#   gpg: WARNING: Using untrusted key!
		echo "quiet" >> $GNUPGHOME/gpg.conf
		if [ "$(git cat-file -t "$tag")" = commit ]; then
			V git verify-commit "$tag"
			msg=.git/COMMIT_EDITMSG
			printf -- "Merge signed commit '%s' into %s\n\n%s" \
				"$tag" \
				"$(git branch --show-current)" \
				"$(git verify-commit "$tag" |& sed 's/^/# /')" > $msg
			cleanup=--cleanup=whitespace
		else
			# In case of signed tag git-merge adds message automatically.
			V git verify-tag "$tag"
		fi
		tagstate=VERIFIED
	else
		warn "Lame upstream, tag is not signed."
		tagstate=unsigned
	fi

	if ! V git merge --progress $cleanup $theirs --no-edit ${msg:+-F "$msg"} "$tag"; then
		if [ -t 0 ]; then
			# Try manual merge if user is here.
			GIT_PS1_SHOWCOLORHINTS=true \
			GIT_PS1_SHOWDIRTYSTATE=true \
			PS1='\w\[\033[1;35m\]$(__git_ps1)\[\033[m\]> ' \
			bash --rcfile <(cat ~/.bashrc; echo . /usr/share/git-core/contrib/completion/git-prompt.sh) || :
		fi
	else
		if [ -n "$theirs" ]; then
			git commit --no-edit --amend --trailer "Merge-Strategy: theirs"
		fi
	fi
	if git diff --quiet &&
	   git diff --quiet --cached &&
	   git merge-base --is-ancestor "$tag" HEAD; then
		info "Merge OK. Continuing..."
	else
		fatal "Merge failed!"
	fi
else
	tagstate=unknown
fi

git rev-parse @^2 >/dev/null 2>&1 || fatal "Not in a merge commit."
git cat-file -p @ | grep -q '^committer .*@altlinux.org>' || fatal "Foreign merge commit."

# What tag is merged?
tags=( $(git tag --points-at @^2) )
case ${#tags[@]} in
	0) fatal "No tags at HEAD." ;;
	1) tag=$tags ;;
	*) warn "Too many tags pointing at HEAD: ${tags[*]}" ;;
esac
ver=${tag#*[Vv]}
info "Top tag is $tag ($tagstate), Version: $ver"
[[ "$ver" =~ ^[[:digit:]]+(.[[:digit:]]+)*$ ]] || fatal "Unknown version format: $ver"

futag=$ver-alt1
[ -z "$force" ] && [ -n "$(git tag -l "$futag")" ] \
	&& fatal "Future tag $futag already exists (--force to skip this check)."

if [ -d /ALT/ ]; then
	repo=${branch-Sisyphus}
	srpm=( /ALT/$repo/files/SRPMS/$NAME-+([^-])-+([^-]).src.rpm )
	suff=${srpm%-*-*.src.rpm}
	revr=${srpm#"$suff-"}
	revr=${revr%.src.rpm}

	case $(rpmevrcmp "$futag" "$revr") in
		-1) fatal "Package version in $repo $revr is newer than $futag";;
		0)  fatal "Package version in $repo $revr is equal to $futag" ;;
		1)  info  "Package version in $repo $revr is older than $futag" ;;
		*)  fatal "'rpmevrcmp $futag $revr' error."
	esac
	unset suff repo
else
	fatal "Package versions cannot be compared (cuz no /ALT/)."
fi

# Vendorize.
cmd=
if [ -f Cargo.toml ]; then
	if type -p cargo-vendor-filterer-no >/dev/null; then
		cmd="cargo vendor-filterer"
		rm -rf vendor
		V cargo vendor-filterer \
			--platform=x86_64-unknown-linux-gnu
	else
		cmd="cargo vendor"
		V cargo vendor --quiet
		# Delete windows' garbage.
		V find vendor \( -path '*win*' -o -path '*vcpkg*' \) \
			\( -name '*.a' -o -name '*.lib' -o -name '*.exe' \) \
			-delete
		# Except: *.obj
	fi
	git add -f Cargo.lock
elif [ -f go.mod ]; then
	cmd="go mod vendor"
	V $cmd
fi
if [ -n "$cmd" ] && [ -d vendor ]; then
	grep -sq -w 'text' .gitattributes && echo '* -text' > vendor/.gitattributes
	V git add -f -A vendor
	if git diff --quiet --cached; then
		info "Vendoring is unchanged."
	else
		V git commit -q -m "ALT: $cmd"
	fi
fi

sver=$(grep -Po '^Version:\s*\K\S+' "$specfile")
[ -n "$sver" ] || fatal "No 'Version:' found in $specfile"
# $sver is unquoted to detect parse errors.
# shellcheck disable=SC2086
case $(rpmvercmp "$ver" $sver) in
	-1) fatal "Version in $specfile is newer than $ver" ;;
	0)  fatal "Version in $specfile is equal to $ver" ;;
	1) ;;
	*)  fatal "'rpmvercmp $ver $sver' error." ;;
esac

# Modify spec.
new_tag_date=$(git log -1 --pretty=format:%cd --date=format:%Y-%m-%d "$tag")
append_changelog="- Update to $tag ($new_tag_date)."
sed -i -E "s/^Version:.*/Version: $ver/" "$specfile"
sed -i -E "s/^Release:.*/Release: alt1/" "$specfile"
safe-add-changelog -e "$append_changelog" "$specfile"

# Build nefore tagging.
[ -n "$build" ] && V gear-hsh --commit 2>&1 | tee build.log

# Tag.
git diff
git add -f "$specfile"
gear-commit --no-edit
git l --first-parent  -3
unset GNUPGHOME
setsid gear-create-tag $force

# Externalize changes.
[ -n "$push" ]  && V git push gitery "$futag" $force
if [ -n "$commit" ]; then
	# shellcheck disable=SC2086
	task=$(V ssh girar task new ${branch-})
	echo "$task" > .gear/task
	V ssh girar task add "$task" repo "$NAME" "$futag"
	V ssh girar task run "$commit" "$task"
fi

